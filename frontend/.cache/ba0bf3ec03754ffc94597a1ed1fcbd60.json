{"dependencies":[{"name":"/home/mishig/Desktop/vizgithub/frontend/package.json","includedInParent":true,"mtime":1523230167415},{"name":"/home/mishig/Desktop/vizgithub/frontend/node_modules/@tensorflow/tfjs-core/package.json","includedInParent":true,"mtime":0}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Pool2DProgram = (function () {\n    function Pool2DProgram(convInfo, poolType, computePositions) {\n        this.variableNames = ['x'];\n        if (poolType === 'avg' && computePositions) {\n            throw new Error('Cannot compute positions for average pool.');\n        }\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var padTop = convInfo.padInfo.top;\n        var padLeft = convInfo.padInfo.left;\n        this.outputShape = convInfo.outShape;\n        var isAvgPool = poolType === 'avg';\n        var initializationValue = '0.0';\n        if (!isAvgPool) {\n            if (poolType === 'min') {\n                initializationValue = '1.0 / 0.0';\n            }\n            else {\n                initializationValue = '-1.0 / 0.0';\n            }\n        }\n        if (computePositions) {\n            var compareOp_1 = poolType === 'min' ? '<=' : '>=';\n            this.userCode = \"\\n        const ivec2 strides = ivec2(\" + strideHeight + \", \" + strideWidth + \");\\n        const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n\\n        void main() {\\n          ivec4 coords = getOutputCoords();\\n          int batch = coords[0];\\n          int d = coords[3];\\n\\n          ivec2 xRCCorner = coords.yz * strides - pads;\\n          int xRCorner = xRCCorner.x;\\n          int xCCorner = xRCCorner.y;\\n\\n          // max/min x(?, ?, d) to get y(yR, yC, d).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n          float avgValue = 0.0;\\n\\n          for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \" + convInfo.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + filterWidth + \"; wC++) {\\n              int xC = xCCorner + wC;\\n\\n              if (xC < 0 || xC >= \" + convInfo.inWidth + \") {\\n                continue;\\n              }\\n\\n              float value = getX(batch, xR, xC, d);\\n\\n              if (isNaN(value)) {\\n                setOutput(value);\\n                return;\\n              }\\n\\n              // If a min / max value has already been found, use it. If not,\\n              // use the current value.\\n              float currMinMaxValue = mix(\\n                  value, minMaxValue, minMaxValueFound);\\n              if (value \" + compareOp_1 + \" currMinMaxValue) {\\n                minMaxValue = value;\\n                minMaxValueFound = 1.0;\\n                minMaxPosition = wR * \" + filterWidth + \" + wC;\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \";\n            return;\n        }\n        var compareOp = poolType === 'min' ? 'min' : 'max';\n        var returnValue = poolType + \"(\" + poolType + \"(\" + poolType + \"(\" +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (poolType === 'avg') {\n            returnValue = \"avgValue / \" + filterHeight * filterWidth + \".0\";\n        }\n        var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n        var filterWidthVec4Remainder = filterWidth % 4;\n        var updateSnippet = \"\\n      if (hasNaN(values)) {\\n        setOutput(getNaN(values));\\n        return;\\n      }\\n      if (\" + isAvgPool + \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = \" + compareOp + \"(values, minMaxValue);\\n      }\\n    \";\n        this.userCode = \"\\n      const ivec2 strides = ivec2(\" + strideHeight + \", \" + strideWidth + \");\\n      const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n      const float initializationValue = \" + initializationValue + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float getValue(int batch, int xR, int xC, int d) {\\n        if (xC < 0 || xC >= \" + convInfo.inWidth + \") {\\n          return initializationValue;\\n        }\\n        return getX(batch, xR, xC, d);\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // max/min x(?, ?, d) to get y(yR, yC, d).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\" + initializationValue + \");\\n        float avgValue = 0.0;\\n\\n        for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n          int xR = xRCorner + wR;\\n\\n          if (xR < 0 || xR >= \" + convInfo.inHeight + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + filterWidthNearestVec4 + \"; wC += 4) {\\n            int xC = xCCorner + wC;\\n\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + 1, d),\\n              getValue(batch, xR, xC + 2, d),\\n              getValue(batch, xR, xC + 3, d)\\n            );\\n\\n            \" + updateSnippet + \"\\n          }\\n\\n          int xC = xCCorner + \" + filterWidthNearestVec4 + \";\\n          if (\" + (filterWidthVec4Remainder === 1) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              initializationValue,\\n              initializationValue,\\n              initializationValue\\n            );\\n            \" + updateSnippet + \"\\n          } else if (\" + (filterWidthVec4Remainder === 2) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + 1, d),\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + updateSnippet + \"\\n          } else if (\" + (filterWidthVec4Remainder === 3) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + 1, d),\\n              getValue(batch, xR, xC + 2, d),\\n              initializationValue\\n            );\\n\\n            \" + updateSnippet + \"\\n          }\\n        }\\n        setOutput(\" + returnValue + \");\\n      }\\n    \";\n    }\n    return Pool2DProgram;\n}());\nexports.Pool2DProgram = Pool2DProgram;\n","map":{"mappings":[{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":1,"column":0},"generated":{"line":1,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":2,"column":0},"generated":{"line":2,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":3,"column":0},"generated":{"line":3,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":4,"column":0},"generated":{"line":4,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":5,"column":0},"generated":{"line":5,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":6,"column":0},"generated":{"line":6,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":7,"column":0},"generated":{"line":7,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":8,"column":0},"generated":{"line":8,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":9,"column":0},"generated":{"line":9,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":10,"column":0},"generated":{"line":10,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":11,"column":0},"generated":{"line":11,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":12,"column":0},"generated":{"line":12,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":13,"column":0},"generated":{"line":13,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":14,"column":0},"generated":{"line":14,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":15,"column":0},"generated":{"line":15,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":16,"column":0},"generated":{"line":16,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":17,"column":0},"generated":{"line":17,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":18,"column":0},"generated":{"line":18,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":19,"column":0},"generated":{"line":19,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":20,"column":0},"generated":{"line":20,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":21,"column":0},"generated":{"line":21,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":22,"column":0},"generated":{"line":22,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":23,"column":0},"generated":{"line":23,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":24,"column":0},"generated":{"line":24,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":25,"column":0},"generated":{"line":25,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":26,"column":0},"generated":{"line":26,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":27,"column":0},"generated":{"line":27,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":28,"column":0},"generated":{"line":28,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":29,"column":0},"generated":{"line":29,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":30,"column":0},"generated":{"line":30,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":31,"column":0},"generated":{"line":31,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":32,"column":0},"generated":{"line":32,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":33,"column":0},"generated":{"line":33,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":34,"column":0},"generated":{"line":34,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":35,"column":0},"generated":{"line":35,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":36,"column":0},"generated":{"line":36,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":37,"column":0},"generated":{"line":37,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":38,"column":0},"generated":{"line":38,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":39,"column":0},"generated":{"line":39,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":40,"column":0},"generated":{"line":40,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":41,"column":0},"generated":{"line":41,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":42,"column":0},"generated":{"line":42,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":43,"column":0},"generated":{"line":43,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":44,"column":0},"generated":{"line":44,"column":0}},{"source":"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js","original":{"line":45,"column":0},"generated":{"line":45,"column":0}}],"sources":{"node_modules/@tensorflow/tfjs-core/dist/kernels/webgl/pool_gpu.js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Pool2DProgram = (function () {\n    function Pool2DProgram(convInfo, poolType, computePositions) {\n        this.variableNames = ['x'];\n        if (poolType === 'avg' && computePositions) {\n            throw new Error('Cannot compute positions for average pool.');\n        }\n        var filterHeight = convInfo.filterHeight;\n        var filterWidth = convInfo.filterWidth;\n        var strideHeight = convInfo.strideHeight;\n        var strideWidth = convInfo.strideWidth;\n        var padTop = convInfo.padInfo.top;\n        var padLeft = convInfo.padInfo.left;\n        this.outputShape = convInfo.outShape;\n        var isAvgPool = poolType === 'avg';\n        var initializationValue = '0.0';\n        if (!isAvgPool) {\n            if (poolType === 'min') {\n                initializationValue = '1.0 / 0.0';\n            }\n            else {\n                initializationValue = '-1.0 / 0.0';\n            }\n        }\n        if (computePositions) {\n            var compareOp_1 = poolType === 'min' ? '<=' : '>=';\n            this.userCode = \"\\n        const ivec2 strides = ivec2(\" + strideHeight + \", \" + strideWidth + \");\\n        const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n\\n        void main() {\\n          ivec4 coords = getOutputCoords();\\n          int batch = coords[0];\\n          int d = coords[3];\\n\\n          ivec2 xRCCorner = coords.yz * strides - pads;\\n          int xRCorner = xRCCorner.x;\\n          int xCCorner = xRCCorner.y;\\n\\n          // max/min x(?, ?, d) to get y(yR, yC, d).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n          float avgValue = 0.0;\\n\\n          for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \" + convInfo.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + filterWidth + \"; wC++) {\\n              int xC = xCCorner + wC;\\n\\n              if (xC < 0 || xC >= \" + convInfo.inWidth + \") {\\n                continue;\\n              }\\n\\n              float value = getX(batch, xR, xC, d);\\n\\n              if (isNaN(value)) {\\n                setOutput(value);\\n                return;\\n              }\\n\\n              // If a min / max value has already been found, use it. If not,\\n              // use the current value.\\n              float currMinMaxValue = mix(\\n                  value, minMaxValue, minMaxValueFound);\\n              if (value \" + compareOp_1 + \" currMinMaxValue) {\\n                minMaxValue = value;\\n                minMaxValueFound = 1.0;\\n                minMaxPosition = wR * \" + filterWidth + \" + wC;\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \";\n            return;\n        }\n        var compareOp = poolType === 'min' ? 'min' : 'max';\n        var returnValue = poolType + \"(\" + poolType + \"(\" + poolType + \"(\" +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (poolType === 'avg') {\n            returnValue = \"avgValue / \" + filterHeight * filterWidth + \".0\";\n        }\n        var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n        var filterWidthVec4Remainder = filterWidth % 4;\n        var updateSnippet = \"\\n      if (hasNaN(values)) {\\n        setOutput(getNaN(values));\\n        return;\\n      }\\n      if (\" + isAvgPool + \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = \" + compareOp + \"(values, minMaxValue);\\n      }\\n    \";\n        this.userCode = \"\\n      const ivec2 strides = ivec2(\" + strideHeight + \", \" + strideWidth + \");\\n      const ivec2 pads = ivec2(\" + padTop + \", \" + padLeft + \");\\n      const float initializationValue = \" + initializationValue + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float getValue(int batch, int xR, int xC, int d) {\\n        if (xC < 0 || xC >= \" + convInfo.inWidth + \") {\\n          return initializationValue;\\n        }\\n        return getX(batch, xR, xC, d);\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // max/min x(?, ?, d) to get y(yR, yC, d).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\" + initializationValue + \");\\n        float avgValue = 0.0;\\n\\n        for (int wR = 0; wR < \" + filterHeight + \"; wR++) {\\n          int xR = xRCorner + wR;\\n\\n          if (xR < 0 || xR >= \" + convInfo.inHeight + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + filterWidthNearestVec4 + \"; wC += 4) {\\n            int xC = xCCorner + wC;\\n\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + 1, d),\\n              getValue(batch, xR, xC + 2, d),\\n              getValue(batch, xR, xC + 3, d)\\n            );\\n\\n            \" + updateSnippet + \"\\n          }\\n\\n          int xC = xCCorner + \" + filterWidthNearestVec4 + \";\\n          if (\" + (filterWidthVec4Remainder === 1) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              initializationValue,\\n              initializationValue,\\n              initializationValue\\n            );\\n            \" + updateSnippet + \"\\n          } else if (\" + (filterWidthVec4Remainder === 2) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + 1, d),\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + updateSnippet + \"\\n          } else if (\" + (filterWidthVec4Remainder === 3) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + 1, d),\\n              getValue(batch, xR, xC + 2, d),\\n              initializationValue\\n            );\\n\\n            \" + updateSnippet + \"\\n          }\\n        }\\n        setOutput(\" + returnValue + \");\\n      }\\n    \";\n    }\n    return Pool2DProgram;\n}());\nexports.Pool2DProgram = Pool2DProgram;\n"},"lineCount":45}},"hash":"04cecf68829462df9b948a4d4d3746f3","cacheData":{"env":{}}}