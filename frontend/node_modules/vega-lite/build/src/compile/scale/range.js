"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var vega_util_1 = require("vega-util");
var channel_1 = require("../../channel");
var log = require("../../log");
var scale_1 = require("../../scale");
var scale_2 = require("../../scale");
var util = require("../../util");
var vega_schema_1 = require("../../vega.schema");
var model_1 = require("../model");
var split_1 = require("../split");
var properties_1 = require("./properties");
exports.RANGE_PROPERTIES = ['range', 'rangeStep', 'scheme'];
function parseScaleRange(model) {
    if (model_1.isUnitModel(model)) {
        parseUnitScaleRange(model);
    }
    else {
        properties_1.parseNonUnitScaleProperty(model, 'range');
    }
}
exports.parseScaleRange = parseScaleRange;
function parseUnitScaleRange(model) {
    var localScaleComponents = model.component.scales;
    // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!
    channel_1.SCALE_CHANNELS.forEach(function (channel) {
        var localScaleCmpt = localScaleComponents[channel];
        if (!localScaleCmpt) {
            return;
        }
        var mergedScaleCmpt = model.getScaleComponent(channel);
        var specifiedScale = model.specifiedScales[channel];
        var fieldDef = model.fieldDef(channel);
        // Read if there is a specified width/height
        var sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;
        var sizeSpecified = sizeType ? !!model.component.layoutSize.get(sizeType) : undefined;
        var scaleType = mergedScaleCmpt.get('type');
        // if autosize is fit, size cannot be data driven
        var rangeStep = util.contains(['point', 'band'], scaleType) || !!specifiedScale.rangeStep;
        if (sizeType && model.fit && !sizeSpecified && rangeStep) {
            log.warn(log.message.CANNOT_FIX_RANGE_STEP_WITH_FIT);
            sizeSpecified = true;
        }
        var xyRangeSteps = getXYRangeStep(model);
        var rangeWithExplicit = parseRangeForChannel(channel, scaleType, fieldDef.type, specifiedScale, model.config, localScaleCmpt.get('zero'), model.mark(), sizeSpecified, model.getName(sizeType), xyRangeSteps);
        localScaleCmpt.setWithExplicit('range', rangeWithExplicit);
    });
}
function getXYRangeStep(model) {
    var xyRangeSteps = [];
    var xScale = model.getScaleComponent('x');
    var xRange = xScale && xScale.get('range');
    if (xRange && vega_schema_1.isVgRangeStep(xRange) && vega_util_1.isNumber(xRange.step)) {
        xyRangeSteps.push(xRange.step);
    }
    var yScale = model.getScaleComponent('y');
    var yRange = yScale && yScale.get('range');
    if (yRange && vega_schema_1.isVgRangeStep(yRange) && vega_util_1.isNumber(yRange.step)) {
        xyRangeSteps.push(yRange.step);
    }
    return xyRangeSteps;
}
/**
 * Return mixins that includes one of the range properties (range, rangeStep, scheme).
 */
function parseRangeForChannel(channel, scaleType, type, specifiedScale, config, zero, mark, sizeSpecified, sizeSignal, xyRangeSteps) {
    var noRangeStep = sizeSpecified || specifiedScale.rangeStep === null;
    // Check if any of the range properties is specified.
    // If so, check if it is compatible and make sure that we only output one of the properties
    for (var _i = 0, RANGE_PROPERTIES_1 = exports.RANGE_PROPERTIES; _i < RANGE_PROPERTIES_1.length; _i++) {
        var property = RANGE_PROPERTIES_1[_i];
        if (specifiedScale[property] !== undefined) {
            var supportedByScaleType = scale_1.scaleTypeSupportProperty(scaleType, property);
            var channelIncompatability = scale_1.channelScalePropertyIncompatability(channel, property);
            if (!supportedByScaleType) {
                log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));
            }
            else if (channelIncompatability) {
                log.warn(channelIncompatability);
            }
            else {
                switch (property) {
                    case 'range':
                        return split_1.makeExplicit(specifiedScale[property]);
                    case 'scheme':
                        return split_1.makeExplicit(parseScheme(specifiedScale[property]));
                    case 'rangeStep':
                        var rangeStep = specifiedScale[property];
                        if (rangeStep !== null) {
                            if (!sizeSpecified) {
                                return split_1.makeExplicit({ step: rangeStep });
                            }
                            else {
                                // If top-level size is specified, we ignore specified rangeStep.
                                log.warn(log.message.rangeStepDropped(channel));
                            }
                        }
                }
            }
        }
    }
    return split_1.makeImplicit(defaultRange(channel, scaleType, type, config, zero, mark, sizeSignal, xyRangeSteps, noRangeStep));
}
exports.parseRangeForChannel = parseRangeForChannel;
function parseScheme(scheme) {
    if (scale_1.isExtendedScheme(scheme)) {
        var r = { scheme: scheme.name };
        if (scheme.count) {
            r.count = scheme.count;
        }
        if (scheme.extent) {
            r.extent = scheme.extent;
        }
        return r;
    }
    return { scheme: scheme };
}
function defaultRange(channel, scaleType, type, config, zero, mark, sizeSignal, xyRangeSteps, noRangeStep) {
    switch (channel) {
        case channel_1.X:
        case channel_1.Y:
            if (util.contains(['point', 'band'], scaleType) && !noRangeStep) {
                if (channel === channel_1.X && mark === 'text') {
                    if (config.scale.textXRangeStep) {
                        return { step: config.scale.textXRangeStep };
                    }
                }
                else {
                    if (config.scale.rangeStep) {
                        return { step: config.scale.rangeStep };
                    }
                }
            }
            // If range step is null, use zero to width or height.
            // Note that these range signals are temporary
            // as they can be merged and renamed.
            // (We do not have the right size signal here since parseLayoutSize() happens after parseScale().)
            // We will later replace these temporary names with
            // the final name in assembleScaleRange()
            if (channel === channel_1.Y && scale_2.hasContinuousDomain(scaleType)) {
                // For y continuous scale, we have to start from the height as the bottom part has the max value.
                return [{ signal: sizeSignal }, 0];
            }
            else {
                return [0, { signal: sizeSignal }];
            }
        case channel_1.SIZE:
            // TODO: support custom rangeMin, rangeMax
            var rangeMin = sizeRangeMin(mark, zero, config);
            var rangeMax = sizeRangeMax(mark, xyRangeSteps, config);
            return [rangeMin, rangeMax];
        case channel_1.SHAPE:
            return 'symbol';
        case channel_1.COLOR:
        case channel_1.FILL:
        case channel_1.STROKE:
            if (scaleType === 'ordinal') {
                // Only nominal data uses ordinal scale by default
                return type === 'nominal' ? 'category' : 'ordinal';
            }
            return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';
        case channel_1.OPACITY:
            // TODO: support custom rangeMin, rangeMax
            return [config.scale.minOpacity, config.scale.maxOpacity];
    }
    /* istanbul ignore next: should never reach here */
    throw new Error("Scale range undefined for channel " + channel);
}
exports.defaultRange = defaultRange;
function sizeRangeMin(mark, zero, config) {
    if (zero) {
        return 0;
    }
    switch (mark) {
        case 'bar':
        case 'tick':
            return config.scale.minBandSize;
        case 'line':
        case 'rule':
            return config.scale.minStrokeWidth;
        case 'text':
            return config.scale.minFontSize;
        case 'point':
        case 'square':
        case 'circle':
            return config.scale.minSize;
    }
    /* istanbul ignore next: should never reach here */
    // sizeRangeMin not implemented for the mark
    throw new Error(log.message.incompatibleChannel('size', mark));
}
function sizeRangeMax(mark, xyRangeSteps, config) {
    var scaleConfig = config.scale;
    // TODO(#1168): make max size scale based on rangeStep / overall plot size
    switch (mark) {
        case 'bar':
        case 'tick':
            if (config.scale.maxBandSize !== undefined) {
                return config.scale.maxBandSize;
            }
            return minXYRangeStep(xyRangeSteps, config.scale) - 1;
        case 'line':
        case 'rule':
            return config.scale.maxStrokeWidth;
        case 'text':
            return config.scale.maxFontSize;
        case 'point':
        case 'square':
        case 'circle':
            if (config.scale.maxSize) {
                return config.scale.maxSize;
            }
            // FIXME this case totally should be refactored
            var pointStep = minXYRangeStep(xyRangeSteps, scaleConfig);
            return (pointStep - 2) * (pointStep - 2);
    }
    /* istanbul ignore next: should never reach here */
    // sizeRangeMax not implemented for the mark
    throw new Error(log.message.incompatibleChannel('size', mark));
}
/**
 * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.
 */
function minXYRangeStep(xyRangeSteps, scaleConfig) {
    if (xyRangeSteps.length > 0) {
        return Math.min.apply(null, xyRangeSteps);
    }
    if (scaleConfig.rangeStep) {
        return scaleConfig.rangeStep;
    }
    return 21; // FIXME: re-evaluate the default value here.
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29tcGlsZS9zY2FsZS9yYW5nZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHVDQUFtQztBQUVuQyx5Q0FBcUg7QUFFckgsK0JBQWlDO0FBRWpDLHFDQVNxQjtBQUNyQixxQ0FBZ0Q7QUFFaEQsaUNBQW1DO0FBQ25DLGlEQUFtRTtBQUNuRSxrQ0FBNEM7QUFDNUMsa0NBQThEO0FBRzlELDJDQUF1RDtBQUsxQyxRQUFBLGdCQUFnQixHQUFvQixDQUFDLE9BQU8sRUFBRSxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFHbEYseUJBQWdDLEtBQVk7SUFDMUMsRUFBRSxDQUFDLENBQUMsbUJBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkIsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUFDLElBQUksQ0FBQyxDQUFDO1FBQ04sc0NBQXlCLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzVDLENBQUM7QUFDSCxDQUFDO0FBTkQsMENBTUM7QUFFRCw2QkFBNkIsS0FBZ0I7SUFDM0MsSUFBTSxvQkFBb0IsR0FBd0IsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUM7SUFFekUsZ0ZBQWdGO0lBQ2hGLHdCQUFjLENBQUMsT0FBTyxDQUFDLFVBQUMsT0FBcUI7UUFDM0MsSUFBTSxjQUFjLEdBQUcsb0JBQW9CLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDckQsRUFBRSxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO1lBQ3BCLE1BQU0sQ0FBQztRQUNULENBQUM7UUFDRCxJQUFNLGVBQWUsR0FBRyxLQUFLLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFHekQsSUFBTSxjQUFjLEdBQUcsS0FBSyxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN0RCxJQUFNLFFB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QUMsS0FBSyxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBQ0QsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDMUIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUM7SUFDL0IsQ0FBQztJQUNELE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyw2Q0FBNkM7QUFDMUQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aXNOdW1iZXJ9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5cbmltcG9ydCB7Q2hhbm5lbCwgQ09MT1IsIEZJTEwsIE9QQUNJVFksIFNDQUxFX0NIQU5ORUxTLCBTY2FsZUNoYW5uZWwsIFNIQVBFLCBTSVpFLCBTVFJPS0UsIFgsIFl9IGZyb20gJy4uLy4uL2NoYW5uZWwnO1xuaW1wb3J0IHtDb25maWd9IGZyb20gJy4uLy4uL2NvbmZpZyc7XG5pbXBvcnQgKiBhcyBsb2cgZnJvbSAnLi4vLi4vbG9nJztcbmltcG9ydCB7TWFya30gZnJvbSAnLi4vLi4vbWFyayc7XG5pbXBvcnQge1xuICBjaGFubmVsU2NhbGVQcm9wZXJ0eUluY29tcGF0YWJpbGl0eSxcbiAgaXNFeHRlbmRlZFNjaGVtZSxcbiAgUmFuZ2UsXG4gIFNjYWxlLFxuICBTY2FsZUNvbmZpZyxcbiAgU2NhbGVUeXBlLFxuICBzY2FsZVR5cGVTdXBwb3J0UHJvcGVydHksXG4gIFNjaGVtZSxcbn0gZnJvbSAnLi4vLi4vc2NhbGUnO1xuaW1wb3J0IHtoYXNDb250aW51b3VzRG9tYWlufSBmcm9tICcuLi8uLi9zY2FsZSc7XG5pbXBvcnQge1R5cGV9IGZyb20gJy4uLy4uL3R5cGUnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7aXNWZ1JhbmdlU3RlcCwgVmdSYW5nZSwgVmdTY2hlbWV9IGZyb20gJy4uLy4uL3ZlZ2Euc2NoZW1hJztcbmltcG9ydCB7aXNVbml0TW9kZWwsIE1vZGVsfSBmcm9tICcuLi9tb2RlbCc7XG5pbXBvcnQge0V4cGxpY2l0LCBtYWtlRXhwbGljaXQsIG1ha2VJbXBsaWNpdH0gZnJvbSAnLi4vc3BsaXQnO1xuaW1wb3J0IHtVbml0TW9kZWx9IGZyb20gJy4uL3VuaXQnO1xuaW1wb3J0IHtTY2FsZUNvbXBvbmVudEluZGV4fSBmcm9tICcuL2NvbXBvbmVudCc7XG5pbXBvcnQge3BhcnNlTm9uVW5pdFNjYWxlUHJvcGVydHl9IGZyb20gJy4vcHJvcGVydGllcyc7XG5cblxuZXhwb3J0IHR5cGUgUmFuZ2VNaXhpbnMgPSB7cmFuZ2U6IFJhbmdlfSB8IHtyYW5nZVN0ZXA6IG51bWJlcn0gfCB7c2NoZW1lOiBTY2hlbWV9O1xuXG5leHBvcnQgY29uc3QgUkFOR0VfUFJPUEVSVElFUzogKGtleW9mIFNjYWxlKVtdID0gWydyYW5nZScsICdyYW5nZVN0ZXAnLCAnc2NoZW1lJ107XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2NhbGVSYW5nZShtb2RlbDogTW9kZWwpIHtcbiAgaWYgKGlzVW5pdE1vZGVsKG1vZGVsKSkge1xuICAgIHBhcnNlVW5pdFNjYWxlUmFuZ2UobW9kZWwpO1xuICB9IGVsc2Uge1xuICAgIHBhcnNlTm9uVW5pdFNjYWxlUHJvcGVydHkobW9kZWwsICdyYW5nZScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVW5pdFNjYWxlUmFuZ2UobW9kZWw6IFVuaXRNb2RlbCkge1xuICBjb25zdCBsb2NhbFNjYWxlQ29tcG9uZW50czogU2NhbGVDb21wb25lbnRJbmRleCA9IG1vZGVsLmNvbXBvbmVudC5zY2FsZXM7XG5cbiAgLy8gdXNlIFNDQUxFX0NIQU5ORUxTIGluc3RlYWQgb2Ygc2NhbGVzW2NoYW5uZWxdIHRvIGVuc3VyZSB0aGF0IHgsIHkgY29tZSBmaXJzdCFcbiAgU0NBTEVfQ0hBTk5FTFMuZm9yRWFjaCgoY2hhbm5lbDogU2NhbGVDaGFubmVsKSA9PiB7XG4gICAgY29uc3QgbG9jYWxTY2FsZUNtcHQgPSBsb2NhbFNjYWxlQ29tcG9uZW50c1tjaGFubmVsXTtcbiAgICBpZiAoIWxvY2FsU2NhbGVDbXB0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZFNjYWxlQ21wdCA9IG1vZGVsLmdldFNjYWxlQ29tcG9uZW50KGNoYW5uZWwpO1xuXG5cbiAgICBjb25zdCBzcGVjaWZpZWRTY2FsZSA9IG1vZGVsLnNwZWNpZmllZFNjYWxlc1tjaGFubmVsXTtcbiAgICBjb25zdCBmaWVsZERlZiA9IG1vZGVsLmZpZWxkRGVmKGNoYW5uZWwpO1xuXG4gICAgLy8gUmVhZCBpZiB0aGVyZSBpcyBhIHNwZWNpZmllZCB3aWR0aC9oZWlnaHRcbiAgICBjb25zdCBzaXplVHlwZSA9IGNoYW5uZWwgPT09ICd4JyA/ICd3aWR0aCcgOiBjaGFubmVsID09PSAneScgPyAnaGVpZ2h0JyA6IHVuZGVmaW5lZDtcbiAgICBsZXQgc2l6ZVNwZWNpZmllZCA9IHNpemVUeXBlID8gISFtb2RlbC5jb21wb25lbnQubGF5b3V0U2l6ZS5nZXQoc2l6ZVR5cGUpIDogdW5kZWZpbmVkO1xuXG4gICAgY29uc3Qgc2NhbGVUeXBlID0gbWVyZ2VkU2NhbGVDbXB0LmdldCgndHlwZScpO1xuXG4gICAgLy8gaWYgYXV0b3NpemUgaXMgZml0LCBzaXplIGNhbm5vdCBiZSBkYXRhIGRyaXZlblxuICAgIGNvbnN0IHJhbmdlU3RlcCA9IHV0aWwuY29udGFpbnMoWydwb2ludCcsICdiYW5kJ10sIHNjYWxlVHlwZSkgfHwgISFzcGVjaWZpZWRTY2FsZS5yYW5nZVN0ZXA7XG4gICAgaWYgKHNpemVUeXBlICYmIG1vZGVsLmZpdCAmJiAhc2l6ZVNwZWNpZmllZCAmJiByYW5nZVN0ZXApIHtcbiAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLkNBTk5PVF9GSVhfUkFOR0VfU1RFUF9XSVRIX0ZJVCk7XG4gICAgICBzaXplU3BlY2lmaWVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB4eVJhbmdlU3RlcHMgPSBnZXRYWVJhbmdlU3RlcChtb2RlbCk7XG5cbiAgICBjb25zdCByYW5nZVdpdGhFeHBsaWNpdCA9IHBhcnNlUmFuZ2VGb3JDaGFubmVsKFxuICAgICAgY2hhbm5lbCwgc2NhbGVUeXBlLCBmaWVsZERlZi50eXBlLCBzcGVjaWZpZWRTY2FsZSwgbW9kZWwuY29uZmlnLFxuICAgICAgbG9jYWxTY2FsZUNtcHQuZ2V0KCd6ZXJvJyksIG1vZGVsLm1hcmsoKSwgc2l6ZVNwZWNpZmllZCwgbW9kZWwuZ2V0TmFtZShzaXplVHlwZSksIHh5UmFuZ2VTdGVwc1xuICAgICk7XG5cbiAgICBsb2NhbFNjYWxlQ21wdC5zZXRXaXRoRXhwbGljaXQoJ3JhbmdlJywgcmFuZ2VXaXRoRXhwbGljaXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0WFlSYW5nZVN0ZXAobW9kZWw6IFVuaXRNb2RlbCkge1xuICBjb25zdCB4eVJhbmdlU3RlcHM6IG51bWJlcltdID0gW107XG5cbiAgY29uc3QgeFNjYWxlID0gbW9kZWwuZ2V0U2NhbGVDb21wb25lbnQoJ3gnKTtcbiAgY29uc3QgeFJhbmdlID0geFNjYWxlICYmIHhTY2FsZS5nZXQoJ3JhbmdlJyk7XG4gIGlmICh4UmFuZ2UgJiYgaXNWZ1JhbmdlU3RlcCh4UmFuZ2UpICYmIGlzTnVtYmVyKHhSYW5nZS5zdGVwKSkge1xuICAgIHh5UmFuZ2VTdGVwcy5wdXNoKHhSYW5nZS5zdGVwKTtcbiAgfVxuXG4gIGNvbnN0IHlTY2FsZSA9IG1vZGVsLmdldFNjYWxlQ29tcG9uZW50KCd5Jyk7XG4gIGNvbnN0IHlSYW5nZSA9IHlTY2FsZSAmJiB5U2NhbGUuZ2V0KCdyYW5nZScpO1xuICBpZiAoeVJhbmdlICYmIGlzVmdSYW5nZVN0ZXAoeVJhbmdlKSAmJiBpc051bWJlcih5UmFuZ2Uuc3RlcCkpIHtcbiAgICB4eVJhbmdlU3RlcHMucHVzaCh5UmFuZ2Uuc3RlcCk7XG4gIH1cblxuICByZXR1cm4geHlSYW5nZVN0ZXBzO1xufVxuXG4vKipcbiAqIFJldHVybiBtaXhpbnMgdGhhdCBpbmNsdWRlcyBvbmUgb2YgdGhlIHJhbmdlIHByb3BlcnRpZXMgKHJhbmdlLCByYW5nZVN0ZXAsIHNjaGVtZSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJhbmdlRm9yQ2hhbm5lbChcbiAgICBjaGFubmVsOiBDaGFubmVsLCBzY2FsZVR5cGU6IFNjYWxlVHlwZSwgdHlwZTogVHlwZSwgc3BlY2lmaWVkU2NhbGU6IFNjYWxlLCBjb25maWc6IENvbmZpZyxcbiAgICB6ZXJvOiBib29sZWFuLCBtYXJrOiBNYXJrLCBzaXplU3BlY2lmaWVkOiBib29sZWFuLCBzaXplU2lnbmFsOiBzdHJpbmcsIHh5UmFuZ2VTdGVwczogbnVtYmVyW11cbiAgKTogRXhwbGljaXQ8VmdSYW5nZT4ge1xuXG4gIGNvbnN0IG5vUmFuZ2VTdGVwID0gc2l6ZVNwZWNpZmllZCB8fCBzcGVjaWZpZWRTY2FsZS5yYW5nZVN0ZXAgPT09IG51bGw7XG5cbiAgLy8gQ2hlY2sgaWYgYW55IG9mIHRoZSByYW5nZSBwcm9wZXJ0aWVzIGlzIHNwZWNpZmllZC5cbiAgLy8gSWYgc28sIGNoZWNrIGlmIGl0IGlzIGNvbXBhdGlibGUgYW5kIG1ha2Ugc3VyZSB0aGF0IHdlIG9ubHkgb3V0cHV0IG9uZSBvZiB0aGUgcHJvcGVydGllc1xuICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIFJBTkdFX1BST1BFUlRJRVMpIHtcbiAgICBpZiAoc3BlY2lmaWVkU2NhbGVbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHN1cHBvcnRlZEJ5U2NhbGVUeXBlID0gc2NhbGVUeXBlU3VwcG9ydFByb3BlcnR5KHNjYWxlVHlwZSwgcHJvcGVydHkpO1xuICAgICAgY29uc3QgY2hhbm5lbEluY29tcGF0YWJpbGl0eSA9IGNoYW5uZWxTY2FsZVByb3BlcnR5SW5jb21wYXRhYmlsaXR5KGNoYW5uZWwsIHByb3BlcnR5KTtcbiAgICAgIGlmICghc3VwcG9ydGVkQnlTY2FsZVR5cGUpIHtcbiAgICAgICAgbG9nLndhcm4obG9nLm1lc3NhZ2Uuc2NhbGVQcm9wZXJ0eU5vdFdvcmtXaXRoU2NhbGVUeXBlKHNjYWxlVHlwZSwgcHJvcGVydHksIGNoYW5uZWwpKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbEluY29tcGF0YWJpbGl0eSkgeyAvLyBjaGFubmVsXG4gICAgICAgIGxvZy53YXJuKGNoYW5uZWxJbmNvbXBhdGFiaWxpdHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgICAgIGNhc2UgJ3JhbmdlJzpcbiAgICAgICAgICAgIHJldHVybiBtYWtlRXhwbGljaXQoc3BlY2lmaWVkU2NhbGVbcHJvcGVydHldKTtcbiAgICAgICAgICBjYXNlICdzY2hlbWUnOlxuICAgICAgICAgICAgcmV0dXJuIG1ha2VFeHBsaWNpdChwYXJzZVNjaGVtZShzcGVjaWZpZWRTY2FsZVtwcm9wZXJ0eV0pKTtcbiAgICAgICAgICBjYXNlICdyYW5nZVN0ZXAnOlxuICAgICAgICAgICAgY29uc3QgcmFuZ2VTdGVwID0gc3BlY2lmaWVkU2NhbGVbcHJvcGVydHldO1xuICAgICAgICAgICAgaWYgKHJhbmdlU3RlcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoIXNpemVTcGVjaWZpZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZUV4cGxpY2l0KHtzdGVwOiByYW5nZVN0ZXB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0b3AtbGV2ZWwgc2l6ZSBpcyBzcGVjaWZpZWQsIHdlIGlnbm9yZSBzcGVjaWZpZWQgcmFuZ2VTdGVwLlxuICAgICAgICAgICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLnJhbmdlU3RlcERyb3BwZWQoY2hhbm5lbCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1ha2VJbXBsaWNpdChcbiAgICBkZWZhdWx0UmFuZ2UoXG4gICAgICBjaGFubmVsLCBzY2FsZVR5cGUsIHR5cGUsIGNvbmZpZyxcbiAgICAgIHplcm8sIG1hcmssIHNpemVTaWduYWwsIHh5UmFuZ2VTdGVwcywgbm9SYW5nZVN0ZXBcbiAgICApXG4gICk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2NoZW1lKHNjaGVtZTogU2NoZW1lKSB7XG4gIGlmIChpc0V4dGVuZGVkU2NoZW1lKHNjaGVtZSkpIHtcbiAgICBjb25zdCByOiBWZ1NjaGVtZSA9IHtzY2hlbWU6IHNjaGVtZS5uYW1lfTtcbiAgICBpZiAoc2NoZW1lLmNvdW50KSB7XG4gICAgICByLmNvdW50ID0gc2NoZW1lLmNvdW50O1xuICAgIH1cbiAgICBpZiAoc2NoZW1lLmV4dGVudCkge1xuICAgICAgci5leHRlbnQgPSBzY2hlbWUuZXh0ZW50O1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICByZXR1cm4ge3NjaGVtZTogc2NoZW1lfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSYW5nZShcbiAgY2hhbm5lbDogQ2hhbm5lbCwgc2NhbGVUeXBlOiBTY2FsZVR5cGUsIHR5cGU6IFR5cGUsIGNvbmZpZzogQ29uZmlnLCB6ZXJvOiBib29sZWFuLCBtYXJrOiBNYXJrLFxuICBzaXplU2lnbmFsOiBzdHJpbmcsIHh5UmFuZ2VTdGVwczogbnVtYmVyW10sIG5vUmFuZ2VTdGVwOiBib29sZWFuXG4pOiBWZ1JhbmdlIHtcbiAgc3dpdGNoIChjaGFubmVsKSB7XG4gICAgY2FzZSBYOlxuICAgIGNhc2UgWTpcbiAgICAgIGlmICh1dGlsLmNvbnRhaW5zKFsncG9pbnQnLCAnYmFuZCddLCBzY2FsZVR5cGUpICYmICFub1JhbmdlU3RlcCkge1xuICAgICAgICBpZiAoY2hhbm5lbCA9PT0gWCAmJiBtYXJrID09PSAndGV4dCcpIHtcbiAgICAgICAgICBpZiAoY29uZmlnLnNjYWxlLnRleHRYUmFuZ2VTdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4ge3N0ZXA6IGNvbmZpZy5zY2FsZS50ZXh0WFJhbmdlU3RlcH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjb25maWcuc2NhbGUucmFuZ2VTdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4ge3N0ZXA6IGNvbmZpZy5zY2FsZS5yYW5nZVN0ZXB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiByYW5nZSBzdGVwIGlzIG51bGwsIHVzZSB6ZXJvIHRvIHdpZHRoIG9yIGhlaWdodC5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGVzZSByYW5nZSBzaWduYWxzIGFyZSB0ZW1wb3JhcnlcbiAgICAgIC8vIGFzIHRoZXkgY2FuIGJlIG1lcmdlZCBhbmQgcmVuYW1lZC5cbiAgICAgIC8vIChXZSBkbyBub3QgaGF2ZSB0aGUgcmlnaHQgc2l6ZSBzaWduYWwgaGVyZSBzaW5jZSBwYXJzZUxheW91dFNpemUoKSBoYXBwZW5zIGFmdGVyIHBhcnNlU2NhbGUoKS4pXG4gICAgICAvLyBXZSB3aWxsIGxhdGVyIHJlcGxhY2UgdGhlc2UgdGVtcG9yYXJ5IG5hbWVzIHdpdGhcbiAgICAgIC8vIHRoZSBmaW5hbCBuYW1lIGluIGFzc2VtYmxlU2NhbGVSYW5nZSgpXG5cbiAgICAgIGlmIChjaGFubmVsID09PSBZICYmIGhhc0NvbnRpbnVvdXNEb21haW4oc2NhbGVUeXBlKSkge1xuICAgICAgICAvLyBGb3IgeSBjb250aW51b3VzIHNjYWxlLCB3ZSBoYXZlIHRvIHN0YXJ0IGZyb20gdGhlIGhlaWdodCBhcyB0aGUgYm90dG9tIHBhcnQgaGFzIHRoZSBtYXggdmFsdWUuXG4gICAgICAgIHJldHVybiBbe3NpZ25hbDogc2l6ZVNpZ25hbH0sIDBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFswLCB7c2lnbmFsOiBzaXplU2lnbmFsfV07XG4gICAgICB9XG4gICAgY2FzZSBTSVpFOlxuICAgICAgLy8gVE9ETzogc3VwcG9ydCBjdXN0b20gcmFuZ2VNaW4sIHJhbmdlTWF4XG4gICAgICBjb25zdCByYW5nZU1pbiA9IHNpemVSYW5nZU1pbihtYXJrLCB6ZXJvLCBjb25maWcpO1xuICAgICAgY29uc3QgcmFuZ2VNYXggPSBzaXplUmFuZ2VNYXgobWFyaywgeHlSYW5nZVN0ZXBzLCBjb25maWcpO1xuICAgICAgcmV0dXJuIFtyYW5nZU1pbiwgcmFuZ2VNYXhdO1xuICAgIGNhc2UgU0hBUEU6XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgY2FzZSBDT0xPUjpcbiAgICBjYXNlIEZJTEw6XG4gICAgY2FzZSBTVFJPS0U6XG4gICAgICBpZiAoc2NhbGVUeXBlID09PSAnb3JkaW5hbCcpIHtcbiAgICAgICAgLy8gT25seSBub21pbmFsIGRhdGEgdXNlcyBvcmRpbmFsIHNjYWxlIGJ5IGRlZmF1bHRcbiAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdub21pbmFsJyA/ICdjYXRlZ29yeScgOiAnb3JkaW5hbCc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFyayA9PT0gJ3JlY3QnIHx8IG1hcmsgPT09ICdnZW9zaGFwZScgPyAnaGVhdG1hcCcgOiAncmFtcCc7XG4gICAgY2FzZSBPUEFDSVRZOlxuICAgICAgLy8gVE9ETzogc3VwcG9ydCBjdXN0b20gcmFuZ2VNaW4sIHJhbmdlTWF4XG4gICAgICByZXR1cm4gW2NvbmZpZy5zY2FsZS5taW5PcGFjaXR5LCBjb25maWcuc2NhbGUubWF4T3BhY2l0eV07XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNob3VsZCBuZXZlciByZWFjaCBoZXJlICovXG4gIHRocm93IG5ldyBFcnJvcihgU2NhbGUgcmFuZ2UgdW5kZWZpbmVkIGZvciBjaGFubmVsICR7Y2hhbm5lbH1gKTtcbn1cblxuZnVuY3Rpb24gc2l6ZVJhbmdlTWluKG1hcms6IE1hcmssIHplcm86IGJvb2xlYW4sIGNvbmZpZzogQ29uZmlnKSB7XG4gIGlmICh6ZXJvKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgc3dpdGNoIChtYXJrKSB7XG4gICAgY2FzZSAnYmFyJzpcbiAgICBjYXNlICd0aWNrJzpcbiAgICAgIHJldHVybiBjb25maWcuc2NhbGUubWluQmFuZFNpemU7XG4gICAgY2FzZSAnbGluZSc6XG4gICAgY2FzZSAncnVsZSc6XG4gICAgICByZXR1cm4gY29uZmlnLnNjYWxlLm1pblN0cm9rZVdpZHRoO1xuICAgIGNhc2UgJ3RleHQnOlxuICAgICAgcmV0dXJuIGNvbmZpZy5zY2FsZS5taW5Gb250U2l6ZTtcbiAgICBjYXNlICdwb2ludCc6XG4gICAgY2FzZSAnc3F1YXJlJzpcbiAgICBjYXNlICdjaXJjbGUnOlxuICAgICAgcmV0dXJuIGNvbmZpZy5zY2FsZS5taW5TaXplO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgbmV2ZXIgcmVhY2ggaGVyZSAqL1xuICAvLyBzaXplUmFuZ2VNaW4gbm90IGltcGxlbWVudGVkIGZvciB0aGUgbWFya1xuICB0aHJvdyBuZXcgRXJyb3IobG9nLm1lc3NhZ2UuaW5jb21wYXRpYmxlQ2hhbm5lbCgnc2l6ZScsIG1hcmspKTtcbn1cblxuZnVuY3Rpb24gc2l6ZVJhbmdlTWF4KG1hcms6IE1hcmssIHh5UmFuZ2VTdGVwczogbnVtYmVyW10sIGNvbmZpZzogQ29uZmlnKSB7XG4gIGNvbnN0IHNjYWxlQ29uZmlnID0gY29uZmlnLnNjYWxlO1xuICAvLyBUT0RPKCMxMTY4KTogbWFrZSBtYXggc2l6ZSBzY2FsZSBiYXNlZCBvbiByYW5nZVN0ZXAgLyBvdmVyYWxsIHBsb3Qgc2l6ZVxuICBzd2l0Y2ggKG1hcmspIHtcbiAgICBjYXNlICdiYXInOlxuICAgIGNhc2UgJ3RpY2snOlxuICAgICAgaWYgKGNvbmZpZy5zY2FsZS5tYXhCYW5kU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjb25maWcuc2NhbGUubWF4QmFuZFNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWluWFlSYW5nZVN0ZXAoeHlSYW5nZVN0ZXBzLCBjb25maWcuc2NhbGUpIC0gMTtcbiAgICBjYXNlICdsaW5lJzpcbiAgICBjYXNlICdydWxlJzpcbiAgICAgIHJldHVybiBjb25maWcuc2NhbGUubWF4U3Ryb2tlV2lkdGg7XG4gICAgY2FzZSAndGV4dCc6XG4gICAgICByZXR1cm4gY29uZmlnLnNjYWxlLm1heEZvbnRTaXplO1xuICAgIGNhc2UgJ3BvaW50JzpcbiAgICBjYXNlICdzcXVhcmUnOlxuICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgICBpZiAoY29uZmlnLnNjYWxlLm1heFNpemUpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5zY2FsZS5tYXhTaXplO1xuICAgICAgfVxuXG4gICAgICAvLyBGSVhNRSB0aGlzIGNhc2UgdG90YWxseSBzaG91bGQgYmUgcmVmYWN0b3JlZFxuICAgICAgY29uc3QgcG9pbnRTdGVwID0gbWluWFlSYW5nZVN0ZXAoeHlSYW5nZVN0ZXBzLCBzY2FsZUNvbmZpZyk7XG4gICAgICByZXR1cm4gKHBvaW50U3RlcCAtIDIpICogKHBvaW50U3RlcCAtIDIpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgbmV2ZXIgcmVhY2ggaGVyZSAqL1xuICAvLyBzaXplUmFuZ2VNYXggbm90IGltcGxlbWVudGVkIGZvciB0aGUgbWFya1xuICB0aHJvdyBuZXcgRXJyb3IobG9nLm1lc3NhZ2UuaW5jb21wYXRpYmxlQ2hhbm5lbCgnc2l6ZScsIG1hcmspKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSYW5nZSBzdGVwIG9mIHggb3IgeSBvciBtaW5pbXVtIGJldHdlZW4gdGhlIHR3byBpZiBib3RoIGFyZSBvcmRpbmFsIHNjYWxlLlxuICovXG5mdW5jdGlvbiBtaW5YWVJhbmdlU3RlcCh4eVJhbmdlU3RlcHM6IG51bWJlcltdLCBzY2FsZUNvbmZpZzogU2NhbGVDb25maWcpOiBudW1iZXIge1xuICBpZiAoeHlSYW5nZVN0ZXBzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkobnVsbCwgeHlSYW5nZVN0ZXBzKTtcbiAgfVxuICBpZiAoc2NhbGVDb25maWcucmFuZ2VTdGVwKSB7XG4gICAgcmV0dXJuIHNjYWxlQ29uZmlnLnJhbmdlU3RlcDtcbiAgfVxuICByZXR1cm4gMjE7IC8vIEZJWE1FOiByZS1ldmFsdWF0ZSB0aGUgZGVmYXVsdCB2YWx1ZSBoZXJlLlxufVxuIl19